CC	     =  g++

# link against
LDFLAGS      =  -lACE

# search for headers here
INCLUDES     =   -I include/ -I include/OTL -I src/OOCore/

# build with these flags
CFLAGS       =  -Wall -g -fno-rtti -Wno-non-virtual-dtor -fPIC -pthread -O0 -fvisibility=hidden -DOMEGA_DEBUG $(INCLUDES)

# use same flags for cpp compilations as used for c compilation
CXXFLAGS     =  $(CFLAGS)

# produce this file
TARGET	     =  libOOCored.so

# sources live here
SRC_DIR	     = src/OOCore

# objs live here, currently having a different OBJ_DIR to SRC_DIR breaks the autogenerated dependencies list 
OBJ_DIR	     = $(SRC_DIR)

# target gets installed here
INSTALL_DIR  = /usr/lib

# target installed with these permisions 
INSTALL_PERM = 755 # rwxr-xr-x

# install command invocations for consistency
INSTALL      = install -m 

# dependencies live in this file
DEPS	     = $(SRC_DIR)/.depend 

# our sources
SRCS	     = $(SRC_DIR)/Registry.cpp     	\
	       $(SRC_DIR)/RunningObjectTable.cpp\
	       $(SRC_DIR)/StdObjectManager.cpp	\
	       $(SRC_DIR)/Threading.cpp		\
	       $(SRC_DIR)/Types.cpp		\
	       $(SRC_DIR)/UserSession.cpp	\
	       $(SRC_DIR)/WireImpl.cpp		\
	       $(SRC_DIR)/WireProxy.cpp		\
	       $(SRC_DIR)/WireStub.cpp		\
	       $(SRC_DIR)/Xml.cpp		\
	       $(SRC_DIR)/Activation.cpp	\
	       $(SRC_DIR)/Channel.cpp		\
	       $(SRC_DIR)/Exception.cpp		\
	       $(SRC_DIR)/OOCore.cpp		\
	       $(SRC_DIR)/OOCore_precomp.h

# our object files
OBJS	     = $(OBJ_DIR)/Registry.o     	\
	       $(OBJ_DIR)/RunningObjectTable.o 	\
	       $(OBJ_DIR)/StdObjectManager.o	\
	       $(OBJ_DIR)/Threading.o		\
	       $(OBJ_DIR)/Types.o		\
	       $(OBJ_DIR)/UserSession.o		\
	       $(OBJ_DIR)/WireImpl.o		\
	       $(OBJ_DIR)/WireProxy.o		\
	       $(OBJ_DIR)/WireStub.o		\
	       $(OBJ_DIR)/Xml.o			\
	       $(OBJ_DIR)/Activation.o		\
	       $(OBJ_DIR)/Channel.o		\
	       $(OBJ_DIR)/Exception.o		\
	       $(OBJ_DIR)/OOCore.o		\

# DEFAULT TARGET
# 1) force  generation of dependency listing
# 2) compile precompiled header
# 3) compile sources
# 4) link objects to produces library
build: $(TARGET)
	@echo "making library $(TARGET)"

# FULL TARGET
# 1) remove dependency listing, object files, target
# 2) execute DEFAULT target
full:clean build

# LIBRARY TARGET
# 1) link object files to produce shared object file
$(TARGET): $(DEPS) $(OBJS)
	@echo "linking library $(TARGET)"
	@$(CC) -shared $(OBJS) $(LDFLAGS) $(CFLAGS) -Wl -o $(TARGET)  

# CLEAN TARGET
# 1) remove dependency listing, object files, target
clean:
	@echo "cleaning project"
	@[ -f $(TARGET) ] && rm -f $(TARGET) && echo "removed $(TARGET)" 
	@rm $(OBJS) && echo "removed $(OBJS)"
	@[ -f $(DEPS) ] && rm -f $(DEPS) && echo "removed $(DEPS)"

# INCLUDE RESOLUTION TARGET
# 1) force  generation of dependency listing
$(DEPS) : depend

# DEPENDENCY GENERATION TARGET
# 1) actual generation of dependency listing
# 2) prepending value of OBJ_DIR to each build target
depend: $(SRCS)
	@$(CC) -MM $(CFLAGS) $(SRCS) | sed -e "s:^[A-Z]:$(OBJ_DIR)/:" > $(DEPS)

include $(DEPS)

# INSTALL TARGET (requires root access)
# 1) copy library to final destination
# 2) chmod target to final permisions
install:
	@! ( $(INSTALL) $(INSTALL_PERM) $(TARGET) $(INSTALL_DIR) )  || echo "$(TARGET) is installed"	
