CC	     =  g++

# link against
LDFLAGS      =   -lACE -lOOCored -lsqlite3 

# search for headers here
INCLUDES     =   -I include/ -I include/OOCore -I include/OTL

# build with these flags
CFLAGS       =  -Wall -g -fno-rtti -Wno-non-virtual-dtor -pthread -O0 -fvisibility=hidden -DOMEGA_DEBUG $(INCLUDES)

# use same flags for cpp compilations as used for c compilation
CXXFLAGS     =  $(CFLAGS)

# produce this file
TARGET	     =  OOServerd

# sources live here
SRC_DIR	     = src/OOServer

# objs live here, currently having a different OBJ_DIR to SRC_DIR breaks the autogenerated dependencies list 
OBJ_DIR	     = $(SRC_DIR)

# target gets installed here
INSTALL_DIR  = /usr/bin

# target installed with these permisions 
INSTALL_PERM = 755 # rwxr-xr-x

# install command invocations for consistency
INSTALL      = install -m 

# dependencies live in this file
DEPS	     = $(SRC_DIR)/.depend 

# our sources
SRCS	     =  $(SRC_DIR)/Channel.cpp 			\
		$(SRC_DIR)/Database.cpp			\
		$(SRC_DIR)/EntryPoint.cpp		\
		$(SRC_DIR)/InterProcessService.cpp	\
		$(SRC_DIR)/DebuggerWin32.cpp		\
		$(SRC_DIR)/MessageConnection.cpp	\
		$(SRC_DIR)/MessagePipeUnix.cpp		\
		$(SRC_DIR)/NTService.cpp		\
		$(SRC_DIR)/NetHttp.cpp			\
		$(SRC_DIR)/NetTcp.cpp			\
		$(SRC_DIR)/RegistryHive.cpp		\
		$(SRC_DIR)/RootManager.cpp		\
		$(SRC_DIR)/RootRegistry.cpp		\
		$(SRC_DIR)/SpawnedProcessUnix.cpp	\
		$(SRC_DIR)/UserRegistry.cpp		\
		$(SRC_DIR)/UserManager.cpp		\
		$(SRC_DIR)/UserNet.cpp			\
		$(SRC_DIR)/UserROT.cpp

# our object files
OBJS	     =  $(OBJ_DIR)/Channel.o 			\
		$(OBJ_DIR)/Database.o			\
		$(OBJ_DIR)/EntryPoint.o			\
		$(OBJ_DIR)/InterProcessService.o	\
		$(OBJ_DIR)/DebuggerWin32.o		\
		$(OBJ_DIR)/MessageConnection.o		\
		$(OBJ_DIR)/MessagePipeUnix.o		\
		$(OBJ_DIR)/NTService.o			\
		$(OBJ_DIR)/NetHttp.o			\
		$(OBJ_DIR)/NetTcp.o			\
		$(OBJ_DIR)/RegistryHive.o		\
		$(OBJ_DIR)/RootManager.o		\
		$(OBJ_DIR)/RootRegistry.o		\
		$(OBJ_DIR)/SpawnedProcessUnix.o		\
		$(OBJ_DIR)/UserRegistry.o		\
		$(OBJ_DIR)/UserManager.o		\
		$(OBJ_DIR)/UserNet.o			\
		$(OBJ_DIR)/UserROT.o

# DEFAULT TARGET
# 1) force  generation of dependency listing
# 2) compile precompiled header
# 3) compile sources
# 4) link objects to produces server
build: $(TARGET)
	@echo "making server $(TARGET)"

# FULL TARGET
# 1) remove dependency listing, object files, target
# 2) execute DEFAULT target
full:clean build

# SERVER TARGET
# 1) link object files to produce server
$(TARGET): $(DEPS) $(OBJS)
	@echo "linking server $(TARGET)"
	@$(CC) $(OBJS) $(LDFLAGS) $(CFLAGS) -o $(TARGET)  

# CLEAN TARGET
# 1) remove dependency listing, object files, target
clean:
	@echo "cleaning project"
	@[ -f $(TARGET) ] && rm -f $(TARGET) && echo "removed $(TARGET)" 
	@rm $(OBJS) && echo "removed $(OBJS)"
	@[ -f $(DEPS) ] && rm -f $(DEPS) && echo "removed $(DEPS)"

# INCLUDE RESOLUTION TARGET
# 1) force  generation of dependency listing
$(DEPS) : depend

# DEPENDENCY GENERATION TARGET
# 1) actual generation of dependency listing
# 2) prepending value of OBJ_DIR to each build target
depend: $(SRCS)
	@$(CC) -MM $(CFLAGS) $(SRCS) | sed -e "s:^[A-Z]:$(OBJ_DIR)/:" > $(DEPS)

include $(DEPS)

# INSTALL TARGET (requires root access)
# 1) copy server to final destination
# 2) chmod target to final permisions
install:
	@! ( $(INSTALL) $(INSTALL_PERM) $(TARGET) $(INSTALL_DIR) )  || echo "$(TARGET) is installed"	
