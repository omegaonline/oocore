


struct Token
{
    size_t m_alloc;
    size_t m_len;
    char*  m_str;
};

struct HttpHeader
{
    char*              m_str;
    struct HttpHeader* m_next;
};

struct HttpRequest
{
    char*              m_source_ip;
    char*              m_method;
    char*              m_resource;
    struct HttpHeader* m_headers;
    BufferHandle       m_data;
};

struct Connection
{
    // Ragel members
    int                 m_cs;
    int                 m_stack[9];
    int                 m_top;

    // Flags for parse state
    unsigned            m_close : 1;
    unsigned            m_chunked : 1;
    unsigned            m_content : 1;

    unsigned long long  m_contentLength;

    struct HttpRequest  m_request;
    struct Token        m_token;

    struct Server*      m_server;
};


%%{
    machine Request;
    access conn->m_;
    
    prepush { if (conn->m_top == (sizeof(conn->m_stack)/sizeof(conn->m_stack[0]))-2) code = 400; }
    
    action append { err = tokenAppend(&conn->m_token,*p); }
    action clear { tokenClear(&conn->m_token); }
    action set_method { err = set_string(conn,&conn->m_request.m_method); }
    action set_resource { err = set_string(conn,&conn->m_request.m_resource); }
    action content_length { err = content_length(conn); }
    action body_push { err = body_push(conn,*p); }
    action header { err = add_header(conn); }
    
    CR = 13;
    LF = 10;
    HT = 9;
    CTL = (0..31);
    CRLF = CR LF;
    SP = 32;
    CHAR = (0..127);
    
    LWS = CRLF? (SP | HT)+;
    
    TEXT = (any - CTL) | LWS;
    
    separators = '(' | ')' | '<' | '>' | '@' | ',' | ';' | ':' | '\\' | '"' | '/' | '[' | ']' | '?' | '=' | '{' | '}' | SP | HT;

	token = (CHAR - (CTL | separators))+;
	
	quoted_pair = '\\' CHAR;	
	qdtext = (TEXT - '"');
	quoted_string = '"' (qdtext | quoted_pair )* '"';
	
	ctext = ( TEXT - (')' | '(') );
	comment = '(' @{ fcall comment_1; };
	comment_1 := ( ctext | quoted_pair | comment )* ')';	
	    
    # RFC 2396 definitions
    mark = '-' | '_' | '.' | '!' | '~' | '*' | "'" | '(' | ')';
    reserved = ';' | '/' | '?' | ':' | '@' | '&' | '=' | '+' | '$' | ',';
    unreserved = alnum | mark;
    escaped = '%' xdigit xdigit;
    scheme = alpha (alpha | digit | '+' | '-' | '.')*;
    userinfo = (unreserved | escaped | ';' | ':' | '&' | '=' | '+' | '$' | ',')*;
    port = digit*;
    domainlabel = alnum | (alnum (alnum | '-')* alnum);
    toplabel = alpha | (alpha (alnum | '-')* alnum);
    hostname = ( domainlabel '.')* toplabel '.'?;
    IPv4address = digit+ '.' digit+ '.' digit+ '.' digit+;
    host = hostname | IPv4address;
    hostport = host ( ':' port )?;
    server = ( userinfo '@' )? hostport;
    reg_name = ( unreserved | escaped | '$' | ',' | ';' | ':' | '@' | '&' | '=' | '+')+;
    authority = server | reg_name;
    pchar = unreserved | escaped | ':' | '@' | '&' | '=' | '+' | '$' | ',';
    param = pchar*;
    segment = pchar* (';' param)*;
    path_segments = segment ( '/' segment)*;
    abs_path = '/' path_segments;
    uric = reserved | unreserved | escaped;
    query = uric*;
    absoluteURI = ('H'|'h')('T'|'t')('T'|'t')('P'|'p') ('S'|'s')? "://" hostport (abs_path? ( '?' query )?) $append @set_resource;
    
    month = "Jan" | "Feb" | "Mar" | "Apr" | "May" | "Jun" | "Jul" | "Aug" | "Sep" | "Oct" | "Nov" | "Dec";    
    weekday = "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday";
    wkday = "Mon" | "Tue" | "Wed" | "Thu" | "Fri" | "Sat" | "Sun";
    date1 = digit{2} SP month SP digit{4};          # day month year (e.g., 02 Jun 1982)
	date2 = digit{2} '-' month '-' digit{2};        # day-month-year (e.g., 02-Jun-82)
	date3 = month SP ( digit{2} | ( SP digit ));    # month day (e.g., Jun  2)
	time = digit{2} ':' digit{2} ':' digit{2};      # 00:00:00 - 23:59:59
    asctime_date = wkday SP date3 SP time SP digit{4};
    rfc850_date = weekday ',' SP date2 SP time SP "GMT";
    rfc1123_date = wkday ',' SP date1 SP time SP "GMT";            
	HTTP_date = rfc1123_date | rfc850_date | asctime_date;
    
	HTTP_Version = "HTTP/" ( ( ('0'+ '.' digit+) | ('0'* '1.' '0'+) ) @{ conn->m_close=1; } | ( '0'* ('1'..'9') digit* '.' '0'* ('1'..'9') digit* ) @{ conn->m_close=0; } );
    
    Method = token $append;
    
    Request_URI = ('*' $append | absoluteURI | ( abs_path ( '?' query )? ) $append | authority $append );

    Request_Line = Method SP @set_method Request_URI SP @set_resource HTTP_Version CRLF; 
    
    field_name = token;
    
    # Note: We only look for headers we care about!
    cache_control_name = ('C'|'c')('A'|'a')('C'|'c')('H'|'h')('E'|'e') '-' ('C'|'c')('O'|'o')('N'|'n')('T'|'t')('R'|'r')('O'|'o')('L'|'l');
    connection_name = ('C'|'c')('O'|'o')('N'|'n')('N'|'n')('E'|'e')('C'|'c')('T'|'t')('I'|'i')('O'|'o')('N'|'n');
    date_name = ('D'|'d')('A'|'a')('T'|'t')('E'|'e');
    pragma_name = ('P'|'p')('R'|'r')('A'|'a')('G'|'g')('M'|'m')('A'|'a');
    trailer_name = ('T'|'t')('R'|'r')('A'|'a')('I'|'i')('L'|'l')('E'|'e')('R'|'r');
    transfer_encoding_name = ('T'|'t')('R'|'r')('A'|'a')('N'|'n')('S'|'s')('F'|'f')('E'|'e')('R'|'r') '-' ('E'|'e')('N'|'n')('C'|'c')('O'|'o')('D'|'d')('I'|'i')('N'|'n')('G'|'g');
    upgrade_name = ('U'|'u')('P'|'p')('G'|'g')('R'|'r')('A'|'a')('D'|'d')('E'|'e');
    via_name = ('V'|'v')('I'|'i')('A'|'a');
    warning_name = ('W'|'w')('A'|'a')('R'|'r')('N'|'n')('I'|'i')('N'|'n')('G'|'g');
    authorization_name = ('A'|'a')('U'|'u')('T'|'t')('H'|'h')('O'|'o')('R'|'r')('I'|'i')('Z'|'z')('A'|'a')('T'|'t')('I'|'i')('O'|'o')('N'|'n');
    expect_name = ('E'|'e')('X'|'x')('P'|'p')('E'|'e')('C'|'c')('T'|'t');
    host_name = ('H'|'h')('O'|'o')('S'|'s')('T'|'t');
    max_forwards_name = ('M'|'m')('A'|'a')('X'|'x') '-' ('F'|'f')('O'|'o')('R'|'r')('W'|'w')('A'|'a')('R'|'r')('D'|'d')('S'|'s');
    proxy_authorization_name = ('P'|'p')('R'|'r')('O'|'o')('X'|'x')('Y'|'y') '-' ('A'|'a')('U'|'u')('T'|'t')('H'|'h')('O'|'o')('R'|'r')('I'|'i')('Z'|'z')('A'|'a')('T'|'t')('I'|'i')('O'|'o')('N'|'n');
    content_length_name =('C'|'c')('O'|'o')('N'|'n')('T'|'t')('E'|'e')('N'|'n')('T'|'t') '-' ('L'|'l')('E'|'e')('N'|'n')('G'|'g')('T'|'t')('H'|'h');
    content_md5_name = ('C'|'c')('O'|'o')('N'|'n')('T'|'t')('E'|'e')('N'|'n')('T'|'t') '-' ('M'|'m')('|D'|'d') '5';
    te_name = ('T'|'t')('E'|'e');

	# TODO - implement cache control  
	cache_extension = token ( '=' ( token | quoted_string ) )?;
	delta_seconds = digit+;
	cache_directive = "no-cache" | "no-store" | "max-age=" delta_seconds | "max-stale" ( '=' delta_seconds )? | "min-fresh=" delta_seconds | "no-transform" | "only-if-cached" | cache_extension;         
    Cache_Control = cache_control_name ':' LWS* cache_directive ( LWS* ',' LWS* cache_directive )* LWS*; 
    
    connection_token = "close" @{ conn->m_close=1; } | token;    
    Connection = connection_name ':' LWS* connection_token ( LWS* ',' LWS* connection_token )* LWS*;
    
    Date = date_name ':' LWS* HTTP_date LWS*;
    
    extension_pragma = token ( '=' ( token | quoted_string ) )?;
    pragma_directive = "no-cache" | extension_pragma;
    Pragma = pragma_name ':' LWS* pragma_directive ( LWS* ',' LWS* pragma_directive )* LWS*;
    
    trailer_field_name = field_name - (transfer_encoding_name | content_length_name | trailer_name); 
    Trailer = trailer_name ':' LWS* trailer_field_name ( LWS* ',' LWS* trailer_field_name )* LWS*;
    
    # TODO - encoding can include gzip etc...
    value = token | quoted_string;
    attribute = token;
    parameter = attribute '=' value;
    transfer_extension = token ( ';' parameter )*;
    transfer_coding = ("chunked" | transfer_extension) @{ conn->m_chunked=1; conn->m_content=1; };
    Transfer_Encoding = transfer_encoding_name ':' LWS* transfer_coding ( LWS* ',' LWS* transfer_coding )* LWS*;
    
    product_version = token;
    product = token ( '/' product_version )?;
    Upgrade = upgrade_name ':' LWS* product ( LWS* ',' LWS* product )* LWS*;
    
    pseudonym = token;
	received_by = ( host [ ":" port ] ) | pseudonym;
	received_protocol = ( token '/' )? token;
	via_part = received_protocol received_by comment?;
    Via = via_name ':' LWS* via_part ( LWS* ',' LWS* via_part )* LWS*;
    
    warn_date = '"' HTTP_date '"';
    warn_text = quoted_string;
    warn_agent = hostport | pseudonym;
    warn_code = digit{3}; 
    warning_value = warn_code SP warn_agent SP warn_text ( SP warn_date )?;
    Warning = warning_name ':' LWS* warning_value ( LWS* ',' LWS* warning_value )* LWS*;
        
    # TODO - support virtual hosts?
    Host = host_name ':' LWS* hostport? LWS*;
    
    Max_Forwards = max_forwards_name ':' LWS* digit LWS*;
    
    # We validate and remove this header as we are not a proxy
    Proxy_Authorization = proxy_authorization_name ':' TEXT*;
    
    qvalue = ( '0' ( '.' digit{0,3} )? ) | ( '1' ( '.' '0'{0,3} )? );
    accept_extension = ';' token ( '=' ( token | quoted_string ) )?;
    accept_params = ";q=" qvalue accept_extension*;
    t_codings = "trailers" | ( transfer_extension accept_params? );
    TE = te_name ':' (LWS* t_codings ( LWS* ',' LWS* t_codings )* )? LWS*;
    
    Content_Length = content_length_name ':' @clear (LWS* digit+ $append LWS*) @content_length;
    
    # TODO - Do something with the MD5 hash?
    md5_digest = ( alnum | '+' | '/')+ '='{0,2};
    Content_MD5 = content_md5_name ':' LWS* md5_digest LWS*;
    
    standard_field = cache_control_name | connection_name | date_name | pragma_name | trailer_name | transfer_encoding_name | upgrade_name | via_name | warning_name |
    				authorization_name | expect_name | host_name | max_forwards_name | proxy_authorization_name | te_name | 
    				content_length_name | content_md5_name;
    
    field_content = TEXT*;
    field_value = field_content | LWS;
    extension_name = field_name - standard_field; 
    extension_header = (extension_name ':' field_value?) $append;
        
    general_header = Cache_Control | Connection | Date | Pragma | Trailer | Transfer_Encoding | Upgrade | Via | Warning;
    request_header = Host | Max_Forwards | Proxy_Authorization | TE;
    entity_header = Content_Length | Content_MD5;
        
    headers = ( (general_header | request_header | entity_header) CRLF @clear) | (extension_header CRLF @header);
    
    data = ( any when { conn->m_contentLength-- > 0 } )* $body_push;
    
    entity_body = data; 
    
    trailer = (entity_header CRLF)*;
    chunk_data = data;
    chunk_ext_val = token | quoted_string;
    chunk_ext_name = token;
    chunk_extension = ( ';' chunk_ext_name ( '=' chunk_ext_val )? )*;
    last_chunk = '0'+ chunk_extension? CRLF;
    chunk_size = xdigit+ $append;
    chunk = chunk_size chunk_extension? CRLF @content_length chunk_data CRLF;
    chunked_body = chunk* last_chunk trailer CRLF;
    
    message_body = (entity_body when { !conn->m_chunked }) | (chunked_body when { conn->m_chunked }); 
	
    Request := CRLF? Request_Line headers* (CRLF (message_body when { conn->m_content })) @{ complete = 1;};   
	
}%%

%% write data;

static int set_string( struct Connection* conn, char** ppsz )
{
	int err = tokenCopy(&conn->m_token,ppsz);
	tokenClear(&conn->m_token);
	return err;
}

static int content_length( struct Connection* conn )
{
	conn->m_contentLength = strtoull(tokenCStr(&conn->m_token),NULL,10);
	tokenClear(&conn->m_token);
	return 0;
}

static int body_push( struct Connection* conn, char c )
{
	return bufferMemCopy(conn->m_request.m_data,&c,1);
}

static int add_header( struct Connection* conn )
{
	int err = addRequestHeader(&conn->m_request,tokenCStr(&conn->m_token));
	
	tokenClear(&conn->m_token);
	
	return err;
}

void connectionRestart( struct Connection* conn )
{
	%% write init;
	
	tokenClear(&conn->m_token);
	
	conn->m_close = 0;
	conn->m_chunked = 0;
	conn->m_content = 0;
	conn->m_contentLength = 0;
	
	resetHttpRequest(&conn->m_request);
}

#include <stdio.h>

int connectionParse( SocketHandle sock, struct Connection* conn, BufferHandle buffer, int* more )
{
	unsigned int code = 0;
    int err = 0;
    int complete = 0;
    
    const char* p = bufferRead(buffer,NULL);
    const char* pe = p + bufferLength(buffer);
    const char* eof = NULL;
    
    *more = 1;
    
    while (p != pe && err == 0 && conn->m_cs != %%{ write error; }%%)
    {
        %% write exec;
    }
    
    if (err == 0)
    {
    	if (conn->m_cs == %%{ write error; }%%)
	    {
	        code = 400;
	    }
	    else if (complete)
	    {
	        if (p != pe)
	        {
	            code = 411;
	        }
	        else
	        {
	        	*more = 0;
	            err = connectionProcess(sock,conn,buffer);
	        }
	    }
    }
    
    if (err != 0)
    {
    	*more = 0;
        err = connectionError(sock,conn,buffer,err);
    }
    else if (code != 0)
    {
    	*more = 0;
    	err = connectionCode(sock,conn,buffer,code); 
    }
    
    return err;
}
