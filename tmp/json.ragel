
%%{
    machine json;
    access fsm->m_;
    
    ws          = 0x20 | 0x09 | 0x0A | 0x0D;
    
    exponent    = ('E' | 'e') ( '-' | '+')? digit+;
    fraction    = '.' digit+;
    integer     = '0' | ([1-9] digit*);
    
    unescaped   = any - ((0x0..0x1F) | 0x22 | 0x5C);
    escape      = 0x22 | 0x5C | 0x2F | 0x62 | 0x66 | 0x6E | 0x72 | 0x74 | ( 0x75 xdigit{4} );
    char        = unescaped | (0x5C escape); 
        
    json :=
    |*
        ws* '[' ws*                        => { if ((err = PushDelim(fsm,JSON_BEGIN_ARRAY))) fbreak; }; 
        ws* '{' ws*                        => { if ((err = PushDelim(fsm,JSON_BEGIN_OBJECT))) fbreak; };
        ws* ']'                            => { if ((err = PushDelim(fsm,JSON_END_ARRAY))) fbreak; };
        ws* '}'                            => { if ((err = PushDelim(fsm,JSON_END_OBJECT))) fbreak; };
        ws* ':' ws*                        => { if ((err = PushToken(fsm,JSON_NAME_SEP))) fbreak; };
        ws* ',' ws*                        => { if ((err = PushToken(fsm,JSON_VALUE_SEP))) fbreak; };
        'false'                            => { if ((err = PushToken(fsm,JSON_FALSE))) fbreak; };
        'null'                             => { if ((err = PushToken(fsm,JSON_NULL))) fbreak; };
        'true'                             => { if ((err = PushToken(fsm,JSON_TRUE))) fbreak; };
        '-'? integer fraction exponent?    => { if ((err = PushFloat(fsm))) fbreak; };
        '-'? integer exponent              => { if ((err = PushFloat(fsm))) fbreak; };
        '-'? integer                       => { if ((err = PushInteger(fsm))) fbreak; };
        '"' char* '"'                      => { if ((err = PushString(fsm))) fbreak; };
    *|;
   
}%%

%% write data nofinal;

struct JsonTokenizer
{
    struct RagelFSM m_base;
    void*           m_param;
    size_t          m_delims;
};

static int PushToken( struct RagelFSM* fsm, unsigned char token_id )
{
    struct JsonToken token;
    
    token.m_type = eJVnull;
    token.m_string = NULL;
    
    return jsonPush(((struct JsonTokenizer*)fsm)->m_param,token_id,&token);
}

static int PushDelim( struct RagelFSM* fsm, unsigned char token_id )
{
    struct JsonTokenizer* this = (struct JsonTokenizer*)fsm;
    struct JsonToken token;
    int err;
    
    if (token_id == JSON_BEGIN_ARRAY ||
        token_id == JSON_BEGIN_OBJECT)
    {
        ++this->m_delims;
    }
    else if (token_id == JSON_END_ARRAY ||
        token_id == JSON_END_OBJECT)
    {
        --this->m_delims;
    }
    
    token.m_type = eJVnull;
    token.m_string = NULL;
    
    err = jsonPush(this->m_param,token_id,&token);
    if (err == 0 && this->m_delims == 0)
    {
        // Push and end token
        err = jsonPush(this->m_param,0,&token);
    }
    return err;
}

static int PushInteger( struct RagelFSM* fsm )
{
    struct JsonToken token;
    char* end_ptr = NULL;
    
    errno = 0;
    
    token.m_type = eJVinteger;
    
#if defined(_MSC_VER)
    token.m_integer = _strtoi64(fsm->m_ts,&end_ptr,10);
#else
    token.m_integer = strtoll(fsm->m_ts,&end_ptr,10);
#endif
    
    if (errno == ERANGE)
    {
        // Use a double instead
        errno = 0;
    
        token.m_type = eJVfloat;
        token.m_float = strtod(fsm->m_ts,&end_ptr);
    }
    
    if (errno != 0)
    {
        return errno;
    }
    else if (end_ptr != fsm->m_te)
    {
        return EINVAL;
    } 
    else
    {
        return jsonPush(((struct JsonTokenizer*)fsm)->m_param,JSON_INTEGER,&token);
    }
}

static int PushFloat( struct RagelFSM* fsm )
{
    struct JsonToken token;
    char* end_ptr = NULL;
    
    errno = 0;
    
    token.m_type = eJVfloat;
    token.m_float = strtod(fsm->m_ts,&end_ptr);
    
    if (errno != 0)
    {
        return errno;
    }
    else if (end_ptr != fsm->m_te)
    {
        return EINVAL;
    } 
    else
    {
        return jsonPush(((struct JsonTokenizer*)fsm)->m_param,JSON_FLOAT,&token);
    }
}

static int AppendStringData( struct JsonToken* token, const char* p, size_t len )
{
    int retval = 0;
    char* new_buf = NULL;
    size_t cur_len = 0;
    if (token->m_string != NULL)
    {
        cur_len = strlen(token->m_string);
    }
    
    new_buf = (char*)malloc(cur_len + len + 1);
    if (new_buf == NULL)
    {
        retval = errno;
    }
    else
    {
        if (token->m_string != NULL)
        {
            strncpy(new_buf,token->m_string,cur_len);
            free(token->m_string);
        }
        
        strncpy(new_buf+cur_len,p,len);
        new_buf[cur_len + len] = '\0';
        
        token->m_string = new_buf;
    }
    
    return retval;
}

static int PushHexDigit( struct JsonToken* token, const char* p )
{
    char bytes[4] = {0,0,0,0};
    size_t len = 0;
    
    unsigned long unicode_char = 0;
         
    int i = 0;
    for (;i<4;++i)
    {
        unicode_char <<= 4;
        
        if (p[i] >= 'a' && p[i] <= 'f')
        {
            unicode_char |= (p[i] - 'a') + 0xA;
        }
        else if (p[i] >= 'A' && p[i] <= 'F')
        {
            unicode_char |= (p[i] - 'A') + 0xA;
        }  
        else
        {
            unicode_char |= (p[i] - '0');
        }
    }
    
    len = utf8Encode(bytes,unicode_char);
    if (len == 0)
    {
        i = errno;
    }
    else
    {
        i = AppendStringData(token,bytes,len);
    }
    
    return i;
}

static int PushString( struct RagelFSM* fsm )
{
    int err = 0;
    struct JsonToken token;
    
    // Manually parse and expand any escaped characters
    const char* start = fsm->m_ts+1;
    const char* p = start;
    
    token.m_type = eJVstring;
    token.m_string = NULL;
    
    for (;p < fsm->m_te-1 && err == 0;++p)
    {
        if (*p == 0x5C)
        {
            if (p > start)
            {
                err = AppendStringData(&token,start,p-start);
            }
            
            if (err == 0)
            {
                char conv = *(++p); 
                switch (conv)
                {
                case 0x62:
                    conv = 0x8;
                    break;
                    
                case 0x66:
                    conv = 0xC;
                    break;
                    
                case 0x6E:
                    conv = 0xA;
                    break;
                    
                case 0x72:
                    conv = 0xD;
                    break;
                    
                case 0x74:
                    conv = 0x9;
                    break;
                
                case 0x75:
                    conv = 0;
                    err = PushHexDigit(&token,++p);
                    p += 3;
                    break;        
                
                default:
                    break;
                }
                
                if (conv != 0)
                {
                    err = AppendStringData(&token,&conv,1);
                }
                
                start = p + 1;
            }
        }
    }
        
    if (err == 0 && p > start)
    {
        err = AppendStringData(&token,start,p-start);
    }
    
    if (err == 0)
    {
        err = jsonPush(((struct JsonTokenizer*)fsm)->m_param,JSON_STRING,&token);
    }
    
    return err;
}

static void Init( struct RagelFSM* fsm )
{
    %% write init;
}

static int Parse( struct RagelFSM* fsm, const char** start, const char* pe, const char* eof )
{
    int err = 0;
    const char* p = *start;
        
    while (p != pe && err == 0 && fsm->m_cs != %%{ write error; }%%)
    {
        // Loop copying bytes
        %% write exec;
    }
    
    if (err == 0)
    {
        if (fsm->m_cs == %%{ write error; }%%)
        {
            err = EINVAL;
        }
        else if (p == eof)
        {
            // Push an 'end' token
            struct JsonToken token;
            token.m_type = eJVnull;
            token.m_string = NULL;
            err = jsonPush(((struct JsonTokenizer*)fsm)->m_param,0,&token);
        }
    }
    
    *start = p;
    return err;
}

struct RagelFSM* createJsonTokenizer( void* param )
{
    struct JsonTokenizer* new_tok = (struct JsonTokenizer*)malloc(sizeof(struct JsonTokenizer));
    if (new_tok)
    {
        int err = ragelInitFSM(&new_tok->m_base,&Parse);
        if (err != 0)
        {
            deleteJsonTokenizer(&new_tok->m_base);
            new_tok = NULL;
            errno = err;
        }
        else
        {
            Init(&new_tok->m_base);
            
            new_tok->m_param = param;
            new_tok->m_delims = 0;
        }
    }

    return (struct RagelFSM*)new_tok;
}

void deleteJsonTokenizer( struct RagelFSM* tok )
{
    struct JsonTokenizer* tokenizer = (struct JsonTokenizer*)tok; 
    if (tokenizer != NULL)
    {
        ragelDestroyFSM(&tokenizer->m_base);
        
        free(tokenizer);
    }
}

%%{
    machine utf16;
    access fsm->m_;

    one_low_le          = (0x00..0x7F) 0x00;
    one_high_le         = (0x80..0xFF) 0x00;
    surrogate_pair_le   = any (0xD8..0xDB) any (0xDC..0xDF);
    two_byte_le         = any (any - (0xD8..0xDF));

    utf16_le :=
    |*
        one_low_le          => { if ((err = Copy(fsm,fsm->m_ts,1,eof))) fbreak; };
        one_high_le         => { if ((err = Transcode(fsm,fsm->m_ts[0],eof))) fbreak; };

        surrogate_pair_le   => { if ((err = TranscodeSurrogate_le(fsm,eof))) fbreak; };
        two_byte_le         => { if ((err = Transcode2(fsm,fsm->m_ts[1],fsm->m_ts[0],eof))) fbreak; };

        any any             => { if ((err = Copy(fsm,s_c_replacement,3,eof))) fbreak; };
    *|;
    
    one_low_be          = 0x00 (0x00..0x7F);
    one_high_be         = 0x00 (0x80..0xFF);
    surrogate_pair_be   = (0xD8..0xDB) any (0xDC..0xDF) any;
    two_byte_be         = (any - (0xD8..0xDF)) any;

    utf16_be :=
    |*
        one_low_be          => { if ((err = Copy(fsm,fsm->m_ts+1,1,eof))) fbreak; };
        one_high_be         => { if ((err = Transcode(fsm,fsm->m_ts[1],eof))) fbreak; };

        surrogate_pair_be   => { if ((err = TranscodeSurrogate_be(fsm,eof))) fbreak; };
        two_byte_be         => { if ((err = Transcode2(fsm,fsm->m_ts[0],fsm->m_ts[1],eof))) fbreak; };

        any any             => { if ((err = Copy(fsm,s_c_replacement,3,eof))) fbreak; };
    *|;

}%%

%% write data noerror nofinal;

static int Copy( struct RagelFSM* fsm, const char* c, int len, const char* eof )
{
    return utfNext((struct UtfFSM*)fsm,c,len,fsm->m_te == eof ? 1 : 0);
}

static int Transcode( struct RagelFSM* fsm, char v, const char* eof )
{
    return utf8EncodeAndPush((struct UtfFSM*)fsm,v,fsm->m_te == eof ? 1 : 0);
}

static int Transcode2( struct RagelFSM* fsm, char hi, char lo, const char* eof )
{
    return utf8EncodeAndPush((struct UtfFSM*)fsm,(hi << 8) | lo,fsm->m_te == eof ? 1 : 0);
}

static int TranscodeSurrogate_le( struct RagelFSM* fsm, const char* eof )
{
    unsigned int hi = (fsm->m_ts[1] & 3) | fsm->m_ts[0];
    unsigned int lo = (fsm->m_ts[3] & 3) | fsm->m_ts[2];

    return utf8EncodeAndPush((struct UtfFSM*)fsm,(hi << 10) | lo,fsm->m_te == eof ? 1 : 0);
}

static int TranscodeSurrogate_be( struct RagelFSM* fsm, const char* eof )
{
    unsigned int hi = (fsm->m_ts[0] & 3) | fsm->m_ts[1];
    unsigned int lo = (fsm->m_ts[2] & 3) | fsm->m_ts[3];

    return utf8EncodeAndPush((struct UtfFSM*)fsm,(hi << 10) | lo,fsm->m_te == eof ? 1 : 0);
}

static void Init( struct RagelFSM* fsm )
{
    %% write init nocs;
}

static int Parse( struct RagelFSM* fsm, const char** start, const char* pe, const char* eof )
{
    int err = 0;
    const char* p = *start;
        
    while (p != pe && err == 0)
    {
        // Loop copying bytes
        %% write exec;
    }
    
    *start = p;
    return err;
}

struct UtfFSM* createUtf16Parser(int big_endian)
{
    struct UtfFSM* retval = (struct UtfFSM*)malloc(sizeof(struct UtfFSM));
    if (retval != NULL)
    {
        int err = ragelInitFSM(&retval->m_base,&Parse);
        if (err != 0)
        {
            ragelDestroyFSM(&retval->m_base);
            free(retval);
            retval = NULL;
            errno = err;
        }
        else
        {
            Init(&retval->m_base);
        
            if (big_endian)
            {
                retval->m_base.m_cs = utf16_en_utf16_be;
            }
            else
            {
                retval->m_base.m_cs = utf16_en_utf16_le;
            }
        }
    }
    
    return retval;    
}

%%{
    machine utf32;
    access fsm->m_;
    
    utf32_le :=
    |*
        (0x00..0x7F) 0x00 0x00 0x00 => { if ((err = Copy(fsm,fsm->m_ts,1,eof))) fbreak; };
        any any (0x00..0x1F) 0x00   => { if ((err = Transcode_le(fsm,eof))) fbreak; };
        any any any any             => { if ((err = Copy(fsm,s_c_replacement,3,eof))) fbreak; };
    *|;

    utf32_be :=
    |*
        0x00 0x00 0x00 (0x00..0x7F) => { if ((err = Copy(fsm,fsm->m_ts+3,1,eof))) fbreak; };
        0x00 (0x00..0x1F) any any   => { if ((err = Transcode_be(fsm,eof))) fbreak; };
        any any any any             => { if ((err = Copy(fsm,s_c_replacement,3,eof))) fbreak; };
    *|;

}%%

%% write data noerror nofinal;

static int Copy( struct RagelFSM* fsm, const char* c, int len, const char* eof )
{
    return utfNext((struct UtfFSM*)fsm,c,len,fsm->m_te == eof ? 1 : 0);
}

static int Transcode_le( struct RagelFSM* fsm, const char* eof )
{
    unsigned long unicode_char = fsm->m_ts[0];
    unicode_char |= (fsm->m_ts[1] << 8);
    unicode_char |= (fsm->m_ts[2] << 16);
        
    return utf8EncodeAndPush((struct UtfFSM*)fsm,unicode_char,fsm->m_te == eof ? 1 : 0);
}

static int Transcode_be( struct RagelFSM* fsm, const char* eof )
{
    unsigned long unicode_char = fsm->m_ts[3];
    unicode_char |= (fsm->m_ts[2] << 8);
    unicode_char |= (fsm->m_ts[1] << 16);
        
    return utf8EncodeAndPush((struct UtfFSM*)fsm,unicode_char,fsm->m_te == eof ? 1 : 0);
}

static void Init( struct RagelFSM* fsm )
{
    %% write init nocs;
}

static int Parse( struct RagelFSM* fsm, const char** start, const char* pe, const char* eof )
{
    int err = 0;
    const char* p = *start;
        
    while (p != pe && err == 0)
    {
        // Loop copying bytes
        %% write exec;
    }
    
    *start = p;
    return err;
}

struct UtfFSM* createUtf32Parser(int big_endian)
{
    struct UtfFSM* retval = (struct UtfFSM*)malloc(sizeof(struct UtfFSM));
    if (retval != NULL)
    {
        int err = ragelInitFSM(&retval->m_base,&Parse);
        if (err != 0)
        {
            ragelDestroyFSM(&retval->m_base);
            free(retval);
            retval = NULL;
            errno = err;
        }
        else
        {
            Init(&retval->m_base);
        
            if (big_endian)
            {
                retval->m_base.m_cs = utf32_en_utf32_be;
            }
            else
            {
                retval->m_base.m_cs = utf32_en_utf32_le;
            }
        }
    }
    
    return retval;   
}

%%{
    machine utf8;
    access fsm->m_;
        
    utf8_cont = 0x80..0xBF;

    one_byte = 0x00..0x7F;

    two_byte_basic      = (0xC0..0xDF) utf8_cont;
    two_byte_overlong   = (0xC0..0xC1) utf8_cont;
    two_byte            = two_byte_basic - two_byte_overlong;

    three_byte_basic    = (0xE0..0xEF) utf8_cont{2};
    three_byte_overlong = 0xE0 (0x80..0x9F) utf8_cont;
    three_byte_reserved = 0xED (0xA0..0xBF) utf8_cont;  # U+D800 to U+DFFF
    three_byte          = three_byte_basic - three_byte_overlong - three_byte_reserved;

    four_byte_basic     = (0xF0..0xF4) utf8_cont{3};
    four_byte_overlong  = 0xF0 (0x80..0x8F) utf8_cont{2};
    four_byte_reserved  = 0xF4 (0x90..0xBF) utf8_cont{2};    # > U+10FFFF
    four_byte           = four_byte_basic - four_byte_overlong - four_byte_reserved;

    valid_bytes         = (one_byte | two_byte | three_byte | four_byte);

    utf8 :=
    |*
        valid_bytes => { if ((err = Copy(fsm,fsm->m_ts,fsm->m_te,eof))) fbreak; };
        any         => { if ((err = Copy(fsm,s_c_replacement,s_c_replacement+3,eof))) fbreak; };
    *|;
}%%

%% write data noerror nofinal;

static int Copy( struct RagelFSM* fsm, const char* start, const char* end, const char* eof )
{
    return utfNext((struct UtfFSM*)fsm,start,end-start,fsm->m_te == eof ? 1 : 0);
}

static void Init( struct RagelFSM* fsm )
{
    %% write init;
}

static int Parse( struct RagelFSM* fsm, const char** start, const char* pe, const char* eof )
{
    int err = 0;
    const char* p = *start;
        
    while (p != pe && err == 0)
    {
        // Loop copying bytes
        %% write exec;
    }
    
    *start = p;    
    return err;
}

struct UtfFSM* createUtf8Parser()
{
    struct UtfFSM* retval = (struct UtfFSM*)malloc(sizeof(struct UtfFSM));
    if (retval != NULL)
    {
        int err = ragelInitFSM(&retval->m_base,&Parse);
        if (err != 0)
        {
            ragelDestroyFSM(&retval->m_base);
            free(retval);
            retval = NULL;
            errno = err;
        }
        else
        {
            Init(&retval->m_base);
        }
    }
    
    return retval;   
}
