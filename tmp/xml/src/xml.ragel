///////////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2011 Rick Taylor
//
// This file is part of OOXML, the Omega Online XML library.
//
// OOXML is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// OOXML is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with OOXML.  If not, see <http://www.gnu.org/licenses/>.
//
///////////////////////////////////////////////////////////////////////////////////

%%{
	machine xml;
	access this->m_;
	alphtype unsigned char;
	
	prepush { pre_push(); }
	
	action return { fret; }
	action append { m_output.push(m_char); }
	action entity { m_entity.push(m_char); }
	
	Char         =    any;  # Prevalidated!
	S            =    (0x20 | 0x9 | 0xD | 0xA)+;
	Eq           =    S? '=' S?;
	#VersionNum   =    '1.' [0-9]+;
	#VersionInfo  =    S 'version' Eq ("'" VersionNum "'" | '"' VersionNum '"');
	VersionInfo  =    S 'version' Eq ("'1.0'" | '"1.0"');
	EncName      =    [A-Za-z] ([A-Za-z0-9._] | '-')*;
	EncodingDecl =    S 'encoding' Eq ('"' EncName '"' | "'" EncName "'" );
	SDDecl       =    S 'standalone' Eq (("'" ('yes' | 'no') "'") | ('"' ('yes' | 'no') '"'));
	XMLDecl      =    '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>';
	Comment      =    '<!--' (Char* -- '--') '-->';
	NameStartChar =   ":" | [A-Z] | "_" | [a-z];          # | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF] 
	NameChar     =    NameStartChar | "-" | "." | [0-9];  # | #xB7 | [#x0300-#x036F] | [#x203F-#x2040] 
	Name         =    (NameStartChar (NameChar)*) $append;
	PITarget     =    Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'));
	PI           =    '<?' PITarget (S (Char* -- '?>'))? $append '?>' @{token("pi",-1);};
	Misc         =    Comment | PI | S;
	SystemLiteral =   ('"' [^"]* '"') | ("'" [^']* "'");
	PubidChar    =    0x20 | 0xD | 0xA | [a-zA-Z0-9] | "-" | ['()+,./:=?;!*#@$_%];
	PubidLiteral =    '"' PubidChar* '"' | "'" (PubidChar - "'")* "'";
	ExternalID   =    'SYSTEM' S SystemLiteral | 'PUBLIC' S PubidLiteral S SystemLiteral;
	Mixed        =    '(' S? '#PCDATA' (S? '|' S? Name)* S? ')*' | '(' S? '#PCDATA' S? ')';
	StringType   =    'CDATA';
	TokenizedType =    'ID' | 'IDREF' | 'IDREFS' | 'ENTITY' | 'ENTITIES' | 'NMTOKEN' | 'NMTOKENS';
	NotationType =    'NOTATION' S '(' S? Name (S? '|' S? Name)* S? ')';
	Nmtoken      =    (NameChar)+;
	Enumeration  =    '(' S? Nmtoken (S? '|' S? Nmtoken)* S? ')';
	EnumeratedType =  NotationType | Enumeration;
	AttType      =    StringType | TokenizedType | EnumeratedType;
	EntityRef    =    '&' (NameStartChar (NameChar)*) $entity ';' @{subst_entity();};
	CharRef      =    '&#' [0-9]+ $entity ';' @{subst_char();} | '&#x' [0-9a-fA-F]+ $entity ';' @{subst_hex();};
	Reference    =    EntityRef | CharRef;
	AttValue     =    ('"' ([^<&"] $append | Reference)*  '"' | "'" ([^<&'] $append | Reference)* "'") @{token("attr_value");};
	DefaultDecl  =    '#REQUIRED' | '#IMPLIED' | (('#FIXED' S)? AttValue);
	AttDef       =    S Name S AttType S DefaultDecl;
	AttlistDecl  =    '<!ATTLIST' S Name AttDef* S? '>';
	PEReference  =    '%' Name ';';
	EntityValue  =    '"' ([^%&"] | PEReference | Reference)* '"' |  "'" ([^%&'] | PEReference | Reference)* "'";
	NDataDecl    =    S 'NDATA' S Name;
	EntityDef    =    EntityValue | (ExternalID NDataDecl?);
	GEDecl       =    '<!ENTITY' S Name S EntityDef S? '>';
	PEDef        =    EntityValue | ExternalID;
	PEDecl       =    '<!ENTITY' S '%' S Name S PEDef S? '>';
	EntityDecl   =    GEDecl | PEDecl;
	PublicID     =    'PUBLIC' S PubidLiteral;
	NotationDecl =    '<!NOTATION' S Name S (ExternalID | PublicID) S? '>';
	DeclSep      =    PEReference | S;
	Attribute    =    Name %{token("attr_name");} Eq AttValue;
	CharData     =    ([^<&]* -- ']]>') $append %{token("text");};
	CDStart      =    '<![CDATA[';
	CData        =    (Char* -- ']]>');
	CDEnd        =    ']]>';
	CDSect       =    CDStart CData CDEnd;
			
	action choice_point { fcall ch_or_seq1; }
	ch_or_seq    =    '(' @choice_point;
	cp           =    (Name | ch_or_seq) ('?' | '*' | '+')?;
	choice       =    S? cp ( S? '|' S? cp )+ S?;
	seq          =    S? cp ( S? ',' S? cp )* S?;	
	ch_or_seq1  :=    (choice | seq) ')' @return;
	children     =    ch_or_seq ('?' | '*' | '+')?;
		
	contentspec  =    'EMPTY' | 'ANY' | Mixed | children;
	elementdecl  =    '<!ELEMENT' S Name S contentspec S? '>';
	markupdecl   =    elementdecl | AttlistDecl | EntityDecl | NotationDecl | PI | Comment ;
	intSubset    =    (markupdecl | DeclSep)*;
	
	action content { fcall content_1; }
	action element_name { token("element_name"); }
	EmptyElemTag =    '<' Name %element_name (S Attribute)* S? '/>' @{token("empty element");};
	STag         =    '<' Name %element_name (S Attribute)* S? '>';
	ETag         =    '</' Name %{token("end element");} S? '>';
	element      =    EmptyElemTag | STag @content;
	content_1   :=    CharData? ((element | Reference | CDSect | PI | Comment) CharData?)* ETag @return;
	
	doctypedecl  =    '<!DOCTYPE' S Name (S ExternalID)? S? ('[' intSubset ']' S?)? '>';
	prolog       =    XMLDecl? Misc* (doctypedecl Misc*)?;
	document     =    prolog element Misc*;	
 
	main := document;
}%%

#include "../src/Tokenizer.h"

%% write data;

void Tokenizer::do_init()
{
	%% write init;
}

bool Tokenizer::do_exec()
{
	static const unsigned char pe = '\0';
	Tokenizer& p = *this;
	
	//while (p != pe && m_cs != %%{ write error; }%% )
	{
		%% write exec;
	}
	
	return (m_cs != %%{ write error; }%%);
}
